\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsmath,clrscode,graphicx,indentfirst}

\author{Олег Смирнов}
\title{Курс kiev-clrs -- Лекция 6. Медианы и порядковые статистики}
\date{16 мая 2009 г.}

\begin{document}
\maketitle
\tableofcontents

\newpage
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\section{Цель лекции}
\begin{itemize}
\item Дать понятие $i$-й порядковой статистики и медианы массива
\item Алгоритм выбора порядковой статистики за линейное ожидаемое время
\item Алгоритм выбора за линейное время в наихудшем случае
\end{itemize}

\section{Введение}

Профессор работает консультантом в нефтяной компании, которая запланирует провести магистральный трубопровод от восточного до западного края нефтяного месторождения с $n$ скважинами. От каждой скважины к магистральному трубопроводу кратчайшим путем проведены рукава. Каким образом профессор может выбрать оптимальное расположение трубопровода (т.е. такое, при котором общая длина всех рукавов была бы минимальной) по заданым координатам скважин ($x$, $y$)?

Легко видеть, что в случае чётного количества скважен $n$, трубопровод можно провести в любом месте при условии, что по обе его стороны (с севера и с юга) будет равное количество скважин. Множества скважин можно представить в виде массива их $y$ координат, отсортированного по возрастанию элементов. Условие будет достигнуто, если трубопровод проходит между скважинами с номерами $n/2$ и $n/2+1$ в указанном массиве.

В случае нечётного количества, можно найти скважину, координата $y$ которой лежит ``в центре'' массива, т.е. с порядковым номером $\frac{n+1}{2}$. Если провести трубопровод через указанную скважину, то растояние до неё будет равно нулю и задача сведется к предыдущему случаю.

\section{Порядковые статистики}

Будем называть $i$-й порядковой статистикой множества, состоящего из $n$ элементов, $i$-й элемент в порядке возратания. Например, минимум такого множества -- это первая порядковая статистика ($i = 1$), а его максимум -- это $n$-я порядковая статистика. Медиана неформально обозначает середину множества. Если $n$ нечётное, то медиана единственная, и её индекс равен $i = \frac{n+1}{2}$; если же $n$ чётное, то медианы две, и их индексы равны $i=n/2$ и $i=n/2 +1$. Таким образом, независимо от чётности $n$, медианы располагаются при $i = \lfloor \frac{n+1}{2} \rfloor$ (нижняя медиана) и $i = \lceil \frac{n+1}{2} \rceil$ (верхняя медиана).

\section{Алгоритм выбора за линейное ожидаемое время}
Идея:

\begin{codebox}
\Procname{$\proc{Random\_Select}(A, p, q, i)$}
\li \If $p = q$
\li \Then \Return $A[p]$
\li $r \gets rand_partition(A, p, q)$ \Comment индекс опорного элемента
\li $k \gets r - p + 1$ \Comment $k = rank(A[r])$
\li \If $i = k$
\li \Then \Return $A[r]$
\li \ElseIf $i < k$
\li \Then \Return $rand_select(A, p, r-1, i)$
\li \Else \Return $rand_select(A, r+1, q, i-k)$
  \End
\End
\end{codebox}

\section{Анализ алгоритма}

\subsection{Лучший случай}
В случае, если алгоритм на каждом шаге генерирует разбиение строго пополам или в любом другом константом соотношении, допустим $1:10$:
\begin{align*}
  T(n) \leqslant T(\frac{9}{10}n) + \Theta(n)
\end{align*}
Решая неравенство по основному методу, получим $T(n) \leqslant \Theta(n)$

\subsection{Худший случай}
Если алгоритм всегда разбивает массив в соотношении $0 \twodots n-1$, время работы:
\begin{equation*}
  T(n) = T(n-1) + \Theta(n) = \Theta(n^2)
\end{equation*}

\subsection{Средний случай}
Пусть $T(n)$ -- случайная величина, показывающая время выполнения алгоритма Random\_Select для массива размера $n$ различных элементов. Необходимо оценить математическое ожидание $E[T(n)]$.

Пусть $X_k$ -- индикаторная случайная величина для $k = 0 \twodots n-1$, равная
\begin{equation*}
  X_k = \begin{cases}
      1, \text{если сгенерировано разбиение } k:n-k-1 \\
      0, \text{иначе}
  \end{cases}
\end{equation*}

\section{Алгоритм выбора за линейное время в наихудшем случае}

Идея алгоритма: генерировать ``хороший'' опорный элемент, используя детерминированную процедуру Partition
\begin{enumerate}
\item Разбиение входного массива на пять групп по $\lfloor n/5 \rfloor$ элементов в каждой и одну группу размером $n \mod{5}$ (возможно пустую)
\item Каждая из пяти групп размера $\lfloor n/5 \rfloor$ сортируется методом вставки, а затем в каждой выбирается медиана
\item Путем рекурсивного вызова алгоритма Select определяется медиана $x$ множества из $\lceil n/5 \rceil$ медиан из пункта 2
\item С помощью алгоритма Partition генерируется разбиение исходного массива относительно медианы $x$
\item Пусть $k = rank(x)$. Алгоритм ветвления аналогичен предыдущему случаю:
\end{enumerate}

\begin{codebox}
\li \If $i = k$ 
\li \Then \Return $x$
\li \ElseIf $i < k$
\li \Then \Return Select($i$-й элемент в меньшей половине разбиения)
\li \ElseIf $i > k$
\li \Then \Return Select($i-k$-й элемент в большей половине)
\End
\end{codebox}

\section{Анализ алгоритма}

\end{document}
